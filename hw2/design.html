<!DOCTYPE html>
<meta charset="utf-8">
<title>Design Studio Implementation</title>
	<style>
	.link {
		stroke: steelblue;
		/*stroke-width: .8px;*/
		opacity: 0.6;
		fill: none;
	}
	
	.node {
		fill: white;
		stroke: #000;
		stroke-width: .9px;
	}
	
	.node:hover {
	fill: black;
	}
	
	.text {
		color: #000;
		font-family: "Times New Roman", Georgia, Serif;
		font-size: 10px;
	}
	
	.node--hidden {
		opacity: 0.1;
	}
	
	.node--highlight {
		opacity: 1;
	}
	
	.link--highlight {
	 	opacity: 1;
		stroke: #000;
	}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<pre>
- show labels so that they dont overlap
- drawing of links / effect
- bundeling
- show gdp/life_expectancy, etc. value
- show title of group inside of circles
- link transition in the beginning does not work
- adjust circle size relative to number of items
- size color or both?
- add layout that shows everything on a map
- calculate gdp/capita
- arrange continents according to geograpical position
- make labels go around
- change size of circles

- questions: which countries are close to this one (lines)

- issues I had: outliniers -> log scale
- show import/export
</pre>
  <form>
  Layout:
    <label><input type="radio" name="layout" value="force3"> Force 3</label>
    <label><input type="radio" name="layout" value="circular1"> Circular 1</label>  
    <label><input type="radio" name="layout" value="circular2"> Circular 2</label>  
    </form>
    <form>
  Group by:
    <label><input type="radio" name="group_by" value="continent"> Continent</label>
    <label><input type="radio" name="group_by" value="population" > Population</label>
    <label><input type="radio" name="group_by" value="gdp" checked> GDP</label>
    <label><input type="radio" name="group_by" value="life_expectancy" > Life Expectancy</label>
 </form>
  <form>
  <form>
  Color:
    <label><input type="radio" name="color" value="nocolor" checked> None</label>
    <label><input type="radio" name="color" value="color_cat" > Category</label>
  </form>
  <form>
  Size:
    <label><input type="radio" name="size" value="nosize" checked> None</label>
    <label><input type="radio" name="size" value="population" > Population</label>
    <label><input type="radio" name="size" value="gdp"> GDP</label>
    <label><input type="radio" name="size" value="life_expectancy" > Life Expectancy</label>
  </form>
  <form>
  Sort:
    <label><input type="radio" name="sort_by" value="population" > Population</label>
    <label><input type="radio" name="sort_by" value="gdp"> GDP</label>
    <label><input type="radio" name="sort_by" value="life_expectancy" > Life Expectancy</label>
  </form>
<script>

d3.json("data/countries_1995_2012.json", function(data) {

var margin = {top: 10, bottom: 10, left: 10, right: 60};
var width = 1100 - margin.left - margin.right;
var height = 900 - margin.top - margin.bottom;

var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

var fill = d3.scale.category10();

var graph = {nodes: [], links: []};

var continents = ["Africa", "Americas", "Asia", "Europe", "Oceania"]; // better performance than implementing some map/foreachs to get the continents automatically
var groupScale = d3.scale.ordinal()
  .domain(continents)
  .rangePoints([-4,4], 0);

var selected_year = 2012;

var node_default_size = 5;

var sort_by = "gdp";

var group_by = "gdp";

var accessor_selected_year_data = function(d) {
  year_data = [];
  d.years.forEach(function(m, i) {
    if (m.year == selected_year)
      year_data = m;
  });

  return year_data;
}

var accessor_population = function(d) {
  return accessor_selected_year_data(d).population;
}

var accessor_gdp = function(d) {
  return accessor_selected_year_data(d).gdp;
}

var accessor_life_expectancy = function(d) {
  return accessor_selected_year_data(d).life_expectancy;
}



// line drawing setup

var diameter = 960,
    radius = diameter / 2,
    innerRadius = radius - 120;

var cluster = d3.layout.cluster()
    .size([360, innerRadius])
    .sort(null)
    .value(function(d) { return d.size; });

var bundle = d3.layout.bundle();

var line = d3.svg.line.radial()
    .interpolate("bundle")
    .tension(.85)
    .radius(function(d) { return d.y; })
    .angle(function(d) { return d.x / 180 * Math.PI; });




var tree = data[0];
data.shift();
tree.children = data;
tree.children.forEach(function(c) { 
c.parent = tree; });

graph.nodes = cluster.nodes(tree);

graph.nodes.forEach(function(d, i) {
  d.years.forEach(function(y, j) {
    if(y.year == selected_year) {
      y.top_partners.forEach(function(p, k) {

        var target_index = graph.nodes.map(function(c) {
                        return c.country_id;
                      }).indexOf(p.country_id);

        if (target_index >= 0)Â { 

          graph.links.push(
            { "source": graph.nodes[i],
              "target": graph.nodes[target_index],
              "value": p.total_export
             }); 
        }
      });
      
    }
  })
})


var lineWidthScale = d3.scale.log()
.domain(d3.extent(graph.links, function(l) { return l.value; }))
.range([0.8, 4]);


// Generate the force layout
var force = d3.layout.force()
    .size([width, height])
    .charge(-50)
    .linkDistance(100)
    .on("tick", tick)
    .on("start", function(d) {})
    .on("end", function(d) {})

function tick(d) {
  graph_update(0);
}


function force_layout_grouped_circular() {

   var r = Math.min(height, width)/2;

  var arc = d3.svg.arc()
         // .outerRadius(r);

  var pie = d3.layout.pie()
          .value(function(d, i) { 
            return 1;  // We want an equal pie share/slice for each point
          });

  var groups = {};
	
  var cats = (group_by == "continent") ? continents : ["Small " + group_by, "Middle " + group_by, "Large " + group_by]; 
  	

  pie(cats).forEach(function(d) {
    d.innerRadius = 0;
    d.outerRadius = r;

    groups[d.data] = {
             "x": arc.centroid(d)[0],
             "y":arc.centroid(d)[1]
            };
  })
 
 
 force.on("tick", function(e){
   var k = 6 * e.alpha;

  graph.nodes.forEach(function(o, i) {
  	if (group_by == "continent") {
		o.x += groups[o.continent].x / 100 * k;
		o.y += groups[o.continent].y / 100 * k;
  	} else {
		o.x += groups[o[group_by]].x / 100 * k;
		o.y += groups[o[group_by]].y / 100 * k;
    }
    });

    graph_update(0);
 });

 force.nodes(graph.nodes)
 //     .links(graph.links)
      .start();
}


function circular_layout() {
  force.stop();

  var r = Math.min(height, width)/2;

  var arc = d3.svg.arc()
         // .outerRadius(r);

  var pie = d3.layout.pie()
          .sort(function(a, b) { 
          if (sort_by == "population")
            return accessor_population(a) - accessor_population(b);
          else
            return accessor_gdp(a) - accessor_gdp(b);
          }) // Sorting
          .value(function(d, i) { 
            return 1;  // We want an equal pie share/slice for each point
          });

  graph.nodes = pie(graph.nodes).map(function(d, i) {
    // Needed to caclulate the centroid
    d.innerRadius = 0;
    d.outerRadius = graph.nodes.length*7.6;

    // Building the data object we are going to return
    d.data.x = arc.centroid(d)[0]+width/2;
    d.data.y = arc.centroid(d)[1]+height/2;

    return d.data;
  })

  graph_update(500);
}


function circular_layout_grouped() {
  force.stop();
  var r = Math.min(height, width)/5;

  var arc = d3.svg.arc()
//          .outerRadius(r);

  var cats = (group_by == "continent") ? continents : ["Small " + group_by, "Middle " + group_by, "Large " + group_by]; 
 

  var pie_groups = d3.layout.pie()
          .value(function(d, i) { 
            return 1;  // We want an equal pie share/slice for each point
          });

  var groups = {};

  pie_groups(cats).forEach(function(d) {
    d.innerRadius = 0;
    d.outerRadius = r;

    groups[d.data] = {
             "x": arc.centroid(d)[0],
             "y":arc.centroid(d)[1]
            };
  })
 
  pie_nodes = d3.layout.pie()
          .sort(function(a, b) { 
          if (sort_by == "population")
            return accessor_population(a) - accessor_population(b);
          else if (sort_by == "life_expectancy")
          	return accessor_life_expectancy(a) - accessor_life_expectancy(b);
          else
            return accessor_gdp(a) - accessor_gdp(b);
          }) // Sorting
          .value(function(d, i) { 
            return 1;  // We want an equal pie share/slice for each point
          });

  var catScale = d3.scale.quantile()
			.domain(d3.extent(graph.nodes, function(l) {
				 return accessor_selected_year_data(l)[group_by]; 
			}))
			.range(cats);

  console.log(catScale.quantiles());

  nested_nodes = d3.nest()
  				.key(function(d) { 
  					if (group_by == "continent")
  				 		return d.continent; 
  				 	else
  				 		return catScale(accessor_selected_year_data(d)[group_by]);
  				 })
  				.rollup(function(leaves) { return pie_nodes(leaves); })
				.entries(graph.nodes);
  graph.nodes = [];
  
  nested_nodes.forEach(function(g) {
  	var group_r = g.values.length*5.5;
  	
    return g.values.forEach(function(d, i) {
        // Needed to caclulate the centroid
        d.innerRadius = 0;
        d.outerRadius = group_r;

        // Building the data object we are going to return

        var offset = (group_by == "continent") ? groups[d.data.continent] : groups[catScale(accessor_selected_year_data(d.data)[group_by])]
         
        d.data.x_label = d.data.x;
        d.data.y_label = d.data.y;
         
        d.data.x = arc.centroid(d)[0]+offset.x*3 + 400;
        d.data.y = arc.centroid(d)[1]+offset.y*3 + 400;

        graph.nodes.push(d.data);
      });
    });

  graph_update(500);
 
}


function category_color() {

  d3.selectAll("circle").transition().duration(500)
                        .style("fill", function(d) { 
                          return fill(d.cat); 
                        });
}

function node_size(field) {
	if (field == "nosize")
  		d3.selectAll("circle").transition().duration(500).attr("r", node_default_size);
	else {
  		var node_scale = d3.scale.log()
  							.domain(d3.extent(graph.nodes, function(l) {
				 				return accessor_selected_year_data(l)[field]; 
							}))
  							.range([2, 7]);
		d3.selectAll("circle").transition().duration(500) .attr("r", function(d) { 
			var r_new = node_scale(accessor_selected_year_data(d)[field]); 
			
			if (!r_new)  {//for some reason sometimes the gdp is null in the dataset..
				return node_scale.range[0];	
				console.log(d);	
			}
			else
				return r_new; 
         });
  	}
                       
}

function graph_update(duration) {

  link.transition().duration(duration)
      .attr("x1", function(d) { return d.target.x; })
      .attr("y1", function(d) { return d.target.y; })
      .attr("x2", function(d) { return d.source.x; })
      .attr("y2", function(d) { return d.source.y; });

  node.transition().duration(duration)
      .attr("transform", function(d) { 
        return "translate("+d.x+","+d.y+")"; 
      });

  /*d3.selectAll(".text")
	  .attr("transform", function(d) { 
		 return "rotate(" + (d.x_label - 90) + ")translate(" + (d.y_label + 8) + ",0)" + (d.x_label < 180 ? "" : "rotate(180)"); })
	    //return "rotate(" + (d.x_label - 90) + ")" + (d.x_label < 180 ? "" : "rotate(180)"); })
	    //return d.x_label < 180 ? "" : "rotate(180)"; })
	  .style("text-anchor", function(d) { 
	  return d.x_label < 180 ? "start" : "end"; });
*/
}

function mouseovered(d) {
   node
   .each(function(n) { n.partner = false; })

  link
  .classed("link--highlight", function(l) { if (l.source === d) return l.target.partner = true; })
    .filter(function(l) { return l.source === d; })
      .each(function() { this.parentNode.appendChild(this); });

  node
  	.classed("node--hidden", function(n) { return !(n.partner || n === d); })
  
   d3.selectAll(".node").each(function() { this.parentNode.appendChild(this); });
}

function mouseouted(d) {
	link
	.classed("link--highlight", false);
		
	  node
	  .classed("node--highlight", false)
	  .classed("node--hidden", false);
	  
	}


d3.select("input[value=\"force3\"]").on("click", force_layout_grouped_circular);
d3.select("input[value=\"circular1\"]").on("click", circular_layout);
d3.select("input[value=\"circular2\"]").on("click", circular_layout_grouped);

d3.select("input[value=\"nocolor\"]").on("click", function() {
  d3.selectAll("circle").transition().duration(500).style("fill", "#66CC66");
})

d3.select("input[value=\"color_cat\"]").on("click", category_color);

d3.selectAll("input[name=\"size\"]").on("click", function() { node_size(this.value); })


d3.selectAll("input[name=\"sort_by\"]").on("click", function(){
	sort_by = this.value; circular_layout_grouped();
});

d3.selectAll("input[name=\"group_by\"]").on("click", function(){
	group_by = this.value; circular_layout_grouped();
});


var link = svg.selectAll(".link")
              .data(graph.links);

link.enter().append("line")
    .attr("class", "link")
   // .attr("d",line)
    .style("stroke-width", function(d) { 
    return lineWidthScale(d.value)
    ; });

var node = svg.selectAll(".node")
              .data(graph.nodes)
            .enter()
              .append("g").attr("class", "node")
		      .on("mouseover", mouseovered)
		      .on("mouseout", mouseouted);

node.append("circle")
    .attr("r", node_default_size)

node.append("text")
  .text(function (d) { return d.name;})
  .attr("x", 7)
  .attr("y", 3)
  .attr("class", "text")

circular_layout_grouped();

});
</script>
</body>
</html>