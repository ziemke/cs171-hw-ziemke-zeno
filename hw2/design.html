<!DOCTYPE html>
<meta charset="utf-8">
<title>Design Studio Implementation</title>
	<style>
	.link_group {
		stroke: steelblue;
		stroke-width: .8px;
		opacity: 0.3;
		fill: none;
	}

	.link_center {
		stroke: grey;
		stroke-width: .8px;
		opacity: 0.1;
		fill: none;
	}
	
	.node {
		fill: white;
		stroke: #000;
		stroke-width: .9px;
	}
	
	.node:hover {
	fill: black;
	}
	
	.text {
		color: #000;
		font-family: "Times New Roman", Georgia, Serif;
		font-size: 10px;
	}
	
	.node--hidden {
		opacity: 0.1;
	}
	
	.node--highlight {
		opacity: 1;
	}
	
	.link_group.link--highlight {
	 	opacity: 1;
		stroke: blue;
	}

	.link_center.link--highlight {
	 	opacity: 0.6;
		stroke: black;
	}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<pre>
- links transitions
- show gdp/life_expectancy, etc. value
- show title of group inside of circles
- size color or both?
- add layout that shows everything on a map
- calculate gdp/capita
- arrange continents according to geograpical position
- change size of circles
- toggle showing different things
- use color


- questions: which countries are close to this one (lines)
- show data in bubble
- make too small circles bigger

- issues I had: outliniers -> log scale
- show import/export

</pre>
<!--

done:
- adjust circle size relative to number of items
-->
<form>
  Group by:
    <label><input type="radio" name="group_by" value="continent"> Continent</label>
    <label><input type="radio" name="group_by" value="population" > Population</label>
    <label><input type="radio" name="group_by" value="gdp" checked> GDP</label>
    <label><input type="radio" name="group_by" value="life_expectancy" > Life Expectancy</label>
 </form>
  <form>
  <form>
 <!-- Color:
    <label><input type="radio" name="color" value="nocolor" checked> None</label>
    <label><input type="radio" name="color" value="color_cat" > Category</label>
  </form>
  <form>-->
  Size:
    <label><input type="radio" name="size" value="nosize" checked> None</label>
    <label><input type="radio" name="size" value="population" > Population</label>
    <label><input type="radio" name="size" value="gdp"> GDP</label>
    <label><input type="radio" name="size" value="life_expectancy" > Life Expectancy</label>
  </form>
  <form>
  Sort:
    <label><input type="radio" name="sort_by" value="population" > Population</label>
    <label><input type="radio" name="sort_by" value="gdp"> GDP</label>
    <label><input type="radio" name="sort_by" value="life_expectancy" > Life Expectancy</label>
  </form>

  <form>
  Year: <span id="year_min"></span><input type="range" name="points" min="1995" max="2012" step="1" value="0" id="slider-time"><span id="year_max"></span>
  </form>
<script>

d3.json("data/countries_1995_2012.json", function(data) {

var margin = {top: 10, bottom: 10, left: 10, right: 60};
var width = 1100 - margin.left - margin.right;
var height = 900 - margin.top - margin.bottom;

var thresholds = { 
"life_expectancy": [60.0510081300813, 75.2657479674797], 
"gdp": [20863000000, 500000000000],
"population": [20740726, 81678051],
}

var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

var fill = d3.scale.category10();

var graph = {nodes: [], links: []};

var continents = ["Asia", "Africa", "Oceania", "Americas", "Europe"]; // better performance than implementing some map/foreachs to get the continents automatically
var groupScale = d3.scale.ordinal()
  .domain(continents)
  .rangePoints([-4,4], 0);

var selected_year = 2012;

var node_default_size = 5;

var sort_by = "gdp";

var group_by = "gdp";

var accessor_selected_year_data = function(d) {
  year_data = [];
  d.years.forEach(function(m, i) {
    if (m.year == selected_year)
      year_data = m;
  });

  return year_data;
}

var accessor_population = function(d) {
  return accessor_selected_year_data(d).population;
}

var accessor_gdp = function(d) {
  return accessor_selected_year_data(d).gdp;
}

var accessor_life_expectancy = function(d) {
  return accessor_selected_year_data(d).life_expectancy;
}



// line drawing setup

var diameter = 960,
    radius = diameter / 2,
    innerRadius = radius - 120;

var cluster = d3.layout.cluster()
    .size([360, innerRadius])
    .sort(null)
    .value(function(d) { return d.size; });

var bundle = d3.layout.bundle();

var lineCenter = d3.svg.line()
    .interpolate("bundle")
    .tension(0.8)
    .x(function(d) { 
    return d.x; })
	.y(function(d,i,g) { 
	return d.y; });

var lineGroup = d3.svg.line()
    .interpolate("bundle")
    .tension(0.3)
    .x(function(d) { 
    return d.x; })
	.y(function(d,i,g) { 
	return d.y; });


updateYearsRange(data);

graph.nodes = data;
var group_magnets = [];
var center_magnet = {"x": width/2, "y": height/2, "name": "center_magnet"};

function generateLinks() {

	graph.links = [];
	
	if(group_magnets.length > 0) {
		center_magnet["children"] = group_magnets;
		group_magnets.forEach(function(m) {
			m.parent = center_magnet;
			m.children.forEach(function(d) {d.parent=m;})	
		})
		
	} else {
		center_magnet = center_magnet["children"] = graph.nodes;
		graph.nodes.forEach(function(d) { d.parent=center_magnet;});
	}

	graph.nodes.forEach(function(d, i) {
	  d.years.forEach(function(y, j) {
		if(y.year == selected_year) {
		  y.top_partners.forEach(function(p, k) {

			var target_index = graph.nodes.map(function(c) {
							return c.country_id;
						  }).indexOf(p.country_id);

			if (target_index >= 0) { 

			  graph.links.push(
				{ "source": graph.nodes[i],
				  "target": graph.nodes[target_index],
				  "value": p.total_export
				 }); 
			}
		  });

		}
	  })
	})

	lineWidthScale.domain(d3.extent(graph.links, function(l) { 
return l.value; }))
}

function angle(d) {
  return (d.startAngle + d.endAngle) * 90 / Math.PI;
}

function updateYearsRange(input_data) {

	// make sure that we catch datasets that might have bigger date ranges than others
	var allYearData = [];
	input_data.forEach(function(country) { 
		country.years.forEach(function(yearData) {
			allYearData.push(yearData); 
		});
	});

	var range = {
		"minimum": d3.min(allYearData, function(d) {return d.year; }), 
		"maximum": d3.max(allYearData, function(d) {return d.year; })
	};

	d3.select("span[id=year_min]").text(range["minimum"]);	
	d3.select("span[id=year_max]").text(range["maximum"]);
	d3.select("input[id=slider-time]")
	  .attr("min", range["minimum"])
	  .attr("max", range["maximum"]);			
  }


var lineWidthScale = d3.scale.log()
.range([0.4, 3.7]);


function circular_layout_grouped(duration, update_links) {
  var r = Math.min(height, width)/5;

  var arc = d3.svg.arc()
//          .outerRadius(r);

  var cats = (group_by == "continent") ? continents : ["Small " + group_by, "Middle " + group_by, "Large " + group_by]; 
 

  var pie_groups = d3.layout.pie()
          .value(function(d, i) { 
            return 1;  // We want an equal pie share/slice for each point
          });

  var groups = {};

  pie_groups(cats).forEach(function(d) {
    d.innerRadius = 0;
    d.outerRadius = r;

    groups[d.data] = {
             "x": arc.centroid(d)[0],
             "y":arc.centroid(d)[1]
            };
  })
 
  pie_nodes = d3.layout.pie()
          .sort(function(a, b) { 
          if (sort_by == "population")
            return accessor_population(a) - accessor_population(b);
          else if (sort_by == "life_expectancy")
          	return accessor_life_expectancy(a) - accessor_life_expectancy(b);
          else
            return accessor_gdp(a) - accessor_gdp(b);
          }) // Sorting
          .value(function(d, i) { 
            return 1;  // We want an equal pie share/slice for each point
          });

  var catScale = d3.scale.threshold()
			.domain(thresholds[group_by])
			.range(cats);

  //console.log(catScale.quantiles());

  nested_nodes = d3.nest()
  				.key(function(d) { 
  					if (group_by == "continent")
  				 		return d.continent; 
  				 	else
  				 		return catScale(accessor_selected_year_data(d)[group_by]);
  				 })
  				.rollup(function(leaves) { return pie_nodes(leaves); })
				.entries(graph.nodes);
  graph.nodes = [];

  group_magnets = [];

  nested_nodes.forEach(function(g) {
  	var offset = groups[g.key];
  	group_magnets.push({
  			"x": offset.x*3 + 400, 
  			"y": offset.y*3 + 400, 
  			"children": g.values.map(function(d) {return d.data;}),
  			"name": g.key
  			});
  });
  
  nested_nodes.forEach(function(g) {
  	var group_r = g.values.length*5.5;

  	if (g.values.length <= 5)
  		group_r *= 3;
  	else if (g.values.length <= 25)
  		group_r *= 1.8;
    return g.values.forEach(function(d, i) {
        // Needed to caclulate the centroid
        d.innerRadius = 0;
        d.outerRadius = group_r;

        // Building the data object we are going to return
		var offset = (group_by == "continent") ? groups[d.data.continent] : groups[catScale(accessor_selected_year_data(d.data)[group_by])]
   
        d.data.x_label = d.data.x;
        d.data.y_label = d.data.y;
         
        d.data.x = arc.centroid(d)[0]+offset.x*3 + 400;
        d.data.y = arc.centroid(d)[1]+offset.y*3 + 400;

        d.data.angle = angle(d);

        graph.nodes.push(d.data);
      });
    });

  if (update_links == true)
  	generateLinks();
  	 
  graph_update(duration);
 
}

function category_color() {

  d3.selectAll("circle").transition().duration(500)
                        .style("fill", function(d) { 
                          return fill(d.cat); 
                        });
}

function node_size(field) {
	if (field == "nosize")
  		d3.selectAll("circle").transition().duration(500).attr("r", node_default_size);
	else {
  		var node_scale = d3.scale.log()
  							.domain(d3.extent(graph.nodes, function(l) {
				 				return accessor_selected_year_data(l)[field]; 
							}))
  							.range([2, 7]);
		d3.selectAll("circle").transition().duration(500) .attr("r", function(d) { 
			var r_new = node_scale(accessor_selected_year_data(d)[field]); 
			
			if (!r_new)  {//for some reason sometimes the gdp is null in the dataset..
				return node_scale.range[0];	
				console.log(d);	
			}
			else
				return r_new; 
         });
  	}
                       
}

function graph_update(duration) {

link.remove();

link = svg.selectAll(".link")
          //.data([bundle(graph.links)[10]])
          .data(bundle(graph.links))

link.exit().remove();

link.enter().append("path")
	.each(function(d) { d.source = d[0], d.target = d[d.length - 1]; })
	.style("stroke-width", function(d) { 
    	 var link_value = 
			graph.links.filter(function(l){ 
				return (d[0].country_id == l.source.country_id && d[d.length-1].country_id == l.target.country_id)
			})[0].value;
			
    	return lineWidthScale(link_value);
    	}
    );

	
link.filter(function(d) {
		return (d[0].parent["name"] != d[d.length-1].parent["name"]);
}).attr("d", lineCenter)
.attr("class", "link_center");


link.filter(function(d) {
		return (d[0].parent["name"] == d[d.length-1].parent["name"]);
}).attr("d", lineGroup)
.attr("class", "link_group");


  //.exit()
//	.remove();

 /* link.transition().duration(duration)
      .attr("x1", function(d) { return d.target.x; })
      .attr("y1", function(d) { return d.target.y; })
      .attr("x2", function(d) { return d.source.x; })
      .attr("y2", function(d) { return d.source.y; });*/

  node.transition().duration(duration)
      .attr("transform", function(d) { 
        return "translate("+d.x+","+d.y+")"; 
      });

	d3.selectAll(".text")
	.transition().duration(duration)
	  .attr("transform", function(d) { return "rotate(" + (d.angle - 90) + ")" +  ((d.angle>180)? "rotate(180)" : "")  })
	  .style("text-anchor", function(d) { 
	  return (d.angle > 180 ? "end" : "start"); })
	  .attr("dx", function(d) { return (d.angle > 180 ? -14 : 0); })
	  .attr("title", function(d) {return d.angle});

}

function mouseovered(d) {
   node
   .each(function(n) { n.partner = false; })

  link
  .classed("link--highlight", function(l) { if (l.source === d) return l.target.partner = true; })
    .filter(function(l) { return l.source === d; })
      .each(function() { this.parentNode.appendChild(this); });

  node
  	.classed("node--hidden", function(n) { return !(n.partner || n === d); })
  
   d3.selectAll(".node").each(function() { this.parentNode.appendChild(this); });
}

function mouseouted(d) {
	link
	.classed("link--highlight", false);
		
	  node
	  .classed("node--highlight", false)
	  .classed("node--hidden", false);
	  
	}


d3.select("input[value=\"nocolor\"]").on("click", function() {
  d3.selectAll("circle").transition().duration(500).style("fill", "#66CC66");
})

d3.select("input[value=\"color_cat\"]").on("click", category_color);

d3.selectAll("input[name=\"size\"]").on("click", function() { node_size(this.value); })


d3.selectAll("input[name=\"sort_by\"]").on("click", function(){
	sort_by = this.value; circular_layout_grouped(500);
});

d3.selectAll("input[name=\"group_by\"]").on("click", function(){
	group_by = this.value; circular_layout_grouped(500);
});

 d3.selectAll("input#slider-time").on("input",
  function() { 
	selected_year = this.value;
	circular_layout_grouped(0, true);
 }); //no transition animation


var link = svg.selectAll(".link")
/*              .data(graph.links);

link.enter().append("line")
    .attr("class", "link")
   // .attr("d",line)
    .style("stroke-width", function(d) { 
    return lineWidthScale(d.value)
    ; });*/

var node = svg.selectAll(".node")
              .data(graph.nodes)
            .enter()
              .append("g").attr("class", "node")
		      .on("mouseover", mouseovered)
		      .on("mouseout", mouseouted);
		    /*  // .on("mouseout", function(d) {
		     // 	if(!this.clicked) {
		      //		mouseouted(d);
		      //	}
		     // 	})
		   //  .on("click", function(d) {
				if (this.clicked) {
					mouseouted(d);
		      		mouseovered(d);
		      	} else {
		      		this.clicked = true;
		      		mouseovered(d);
		      	}
		      } )*/;

node.append("circle")
    .attr("r", node_default_size)

node.append("text")
  .text(function (d) {
  	 return d.name;})
  .attr("x", 7)
  .attr("y", 3)
  .attr("class", "text")

circular_layout_grouped(500, true);

});
</script>
</body>
</html>